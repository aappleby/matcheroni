import argparse

#-------------------------------------------------------------------------------

parser = argparse.ArgumentParser()
parser.add_argument('--verbose',  default=False, action='store_true', help='Print verbose build info')
parser.add_argument('--serial',   default=False, action='store_true', help='Do not parallelize commands')
parser.add_argument('--dryrun',   default=False, action='store_true', help='Do not run commands')
parser.add_argument('--debug',    default=False, action='store_true', help='Dump debugging information')
parser.add_argument('--dotty',    default=False, action='store_true', help='Dump dependency graph as dotty')
parser.add_argument('--release',  default=False, action='store_true', help='Release-mode optimized build')
parser.add_argument('--force',    default=False, action='store_true', help='Force rebuild of everything')
(flags, unrecognized) = parser.parse_known_args()

hancho.config.verbose = flags.verbose
hancho.config.serial  = flags.serial
hancho.config.dryrun  = flags.dryrun
hancho.config.debug   = flags.debug
hancho.config.dotty   = flags.dotty
hancho.config.force   = flags.force

#-------------------------------------------------------------------------------

base_config = hancho.config.extend(
  name        = "base_config",
  build_type  = "debug",
)

if flags.release:
  base_config.build_type = "release"

#-------------------------------------------------------------------------------

compile_cpp = base_config.extend(
  description = "Compiling {file_in} -> {file_out} ({build_type})",
  command     = "{toolchain}-g++ {cpp_std} {gcc_opt} {warnings} {includes} {defines} -c {file_in} -o {file_out}",

  toolchain   = "x86_64-linux-gnu",
  cpp_std     = "-std=c++20",
  gcc_opt     = "{'-O3' if build_type == 'release' else '-g -O0'} -MMD",
  warnings    = "-Wall -Werror -Wno-unused-variable -Wno-unused-local-typedefs -Wno-unused-but-set-variable",
  includes    = "-I.",
  defines     = "",
  file_out    = "{swap_ext(file_in, '.o')}",
  depfile     = "{swap_ext(file_in, '.d')}",
)

link_c_lib = base_config.extend(
  description = "Bundling {file_out}",
  command     = "ar rcs {file_out} {join(files_in)}",
)

link_c_bin = base_config.extend(
  description = "Linking {file_out}",
  command     = "{toolchain}-g++ {ld_opt} {warnings} {join(files_in)} {join(deps)} {sys_libs} -o {file_out}",

  toolchain   = "x86_64-linux-gnu",
  ld_opt      = "{'-O3' if build_type == 'release' else '-g -O0'}",
  warnings    = "-Wall",
  sys_libs    = "",
)

test_rule = base_config.extend(
  description = "Running test {file_in}",
  command     = "rm -f {file_out} && {file_in} {args} && touch {file_out}",
  file_out    = "{file_in}_pass",
  args        = "",
)

#-------------------------------------------------------------------------------

def compile_srcs(srcs, **kwargs):
  return [compile_cpp(file_in = f, **kwargs) for f in srcs]

#-------------------------------------------------------------------------------

def c_binary(*, name, srcs, **kwargs):
  return link_c_bin(
    files_in = compile_srcs(srcs, **kwargs),
    file_out = name,
    **kwargs
  )

#-------------------------------------------------------------------------------

def c_library(*, name, srcs, **kwargs):
  return link_c_lib(
    files_in = compile_srcs(srcs, **kwargs),
    file_out = name,
    **kwargs)

#-------------------------------------------------------------------------------
